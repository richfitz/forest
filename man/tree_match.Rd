\name{tree_match}
\alias{tree_match}
\title{Match Children in Tree Grob}
\usage{
tree_match(tree_grob, class = NULL, name = NULL)
}
\arguments{
  \item{tree_grob}{A grob created by \code{treeGrob}}

  \item{class}{The class of the object to match.  Currently
  this can be any class attribute (for cases with multiple
  inheritance) but this might change soon to be only the
  primary class.  Also it only makes sense to match things
  with a \code{tree_} prefix so that requirement may also
  drop soon.}

  \item{name}{The name of the object to match.  Some
  functions set the name automatically for you (e.g.,
  \code{tree_tip_labels}, but others default to a
  \code{grid} provided name, which is varies from use to
  use unless one is provided manually.}
}
\value{
A list of \code{gPath} objects that can be used to
reference children \emph{relative to} \code{tree_grob}
}
\description{
Match elements within a tree grob (generated by
\code{\link{treeGrob}}), using the name or class of the
child component.
}
\details{
This matches elements that were added to the tree by the
\code{+} operator; such as \code{tree_grob +
tree_node_labels()}.  A few rules are useful here (and may
change).

All classes provided by \code{forest} are prefixed with
\code{tree_}, so elements provided as \code{class} will
almost always need this adding.  I might change things to
automatically add this in the future though, as the prefix
might change.

\code{tree_tip_labels} and \code{tree_node_labels}
\emph{both} produce objects with class \code{tree_labels}.
\code{tree_tip_labels} will always have the \emph{name} of
\code{tips} and \code{tree_node_labels} will always have
the name of \code{nodes}, so they can be addressed with
\code{tree_match(., class="tree_labels", name="tips")}, for
example.

There can be only one set of branches and this always has
the name "branches".

When both specified, \code{class} and \code{name} must
\emph{both} be satisified.
}
\author{
Rich FitzJohn
}

